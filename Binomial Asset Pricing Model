#Messing around with the Binomial Asset Pricing Model

#Setting up the variables
P = 40
X = 41
Rf = .08
sigma = .3
T = 1
N = 3

def pricing_the_security(X, Rf, sigma, T, N, P):
	import numpy as np
	from scipy.stats import binom
	H = T/N
	up = np.exp((Rf*H)+ sigma*(H**(.5)))
	down = np.exp((Rf*H)- sigma*(H**(.5)))
	pu = (np.exp(Rf*H)-down)/(up-down)
	pd = 1 - pu


#setting up the empty array
	tree = np.empty((N+1,N+1))
#calculating out into the future
	j = 1
	tree[0][0] = P
	for i in range(1,N):
		tree[0][i] = tree[0][(i-1)]*up
		tree[j][i] = tree[0][(i-1)]*down
		j+= 1
#can i have it refer to the one before it?
#this may only do the top two rows, there has to be a sleeker way to do this


#pulling out the last column
	end_column = tree[0:N][N+1]
	price = []
	for i in range(N):
		price.append(payoff(X, end_column[i])*probstar)
	weighted_sum = sum(price)
	discounted_price = np.exp((Rf-sigma)*H)*weighted_sum)
	print("The value of the option today is, discounted_price,")
	
	

def payoff(Pt, X):
	return np.maximun(Pt - X, 0.0)

pricing_the_security(X, Rf, sigma, T, N, P)

# i need to keep track of up up up and down down down and up up down etc
# binom.pmf

